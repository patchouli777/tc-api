// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.user.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const userDelete = `-- name: UserDelete :exec
DELETE FROM
    tc_user
WHERE
    id = $1
`

func (q *Queries) UserDelete(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, userDelete, id)
	return err
}

const userInsert = `-- name: UserInsert :one
INSERT INTO tc_user (
    name,
    password,
    avatar)
VALUES (
    $1,
    $2,
    $3)
RETURNING id
`

type UserInsertParams struct {
	Name     string
	Password string
	Avatar   pgtype.Text
}

func (q *Queries) UserInsert(ctx context.Context, arg UserInsertParams) (int32, error) {
	row := q.db.QueryRow(ctx, userInsert, arg.Name, arg.Password, arg.Avatar)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const userSelect = `-- name: UserSelect :one
SELECT
    id,
    name,
    avatar,
    is_banned,
    is_partner,
    first_livestream,
    last_livestream
FROM
    tc_user
WHERE
    id = $1
`

type UserSelectRow struct {
	ID              int32
	Name            string
	Avatar          pgtype.Text
	IsBanned        pgtype.Bool
	IsPartner       pgtype.Bool
	FirstLivestream pgtype.Date
	LastLivestream  pgtype.Date
}

func (q *Queries) UserSelect(ctx context.Context, id int32) (UserSelectRow, error) {
	row := q.db.QueryRow(ctx, userSelect, id)
	var i UserSelectRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Avatar,
		&i.IsBanned,
		&i.IsPartner,
		&i.FirstLivestream,
		&i.LastLivestream,
	)
	return i, err
}

const userSelectByUsername = `-- name: UserSelectByUsername :one
SELECT
    id,
    name,
    avatar,
    is_banned,
    is_partner,
    first_livestream,
    last_livestream
FROM
    tc_user
WHERE
    name = $1
`

type UserSelectByUsernameRow struct {
	ID              int32
	Name            string
	Avatar          pgtype.Text
	IsBanned        pgtype.Bool
	IsPartner       pgtype.Bool
	FirstLivestream pgtype.Date
	LastLivestream  pgtype.Date
}

func (q *Queries) UserSelectByUsername(ctx context.Context, name string) (UserSelectByUsernameRow, error) {
	row := q.db.QueryRow(ctx, userSelectByUsername, name)
	var i UserSelectByUsernameRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Avatar,
		&i.IsBanned,
		&i.IsPartner,
		&i.FirstLivestream,
		&i.LastLivestream,
	)
	return i, err
}

const userUpdate = `-- name: UserUpdate :exec
UPDATE
    tc_user
SET
    name       = CASE WHEN $1::boolean THEN $2 ELSE name END,
    password   = CASE WHEN $3::boolean THEN $4 ELSE password END,
    is_banned  = CASE WHEN $5::boolean THEN $6 ELSE is_banned END,
    is_partner = CASE WHEN $7::boolean THEN $8 ELSE is_partner END,
    avatar     = CASE WHEN $9::boolean THEN $10 ELSE avatar END,
    updated_at = CURRENT_DATE
WHERE
    id = $11
RETURNING id, name, password, created_at, updated_at, is_banned, is_partner, first_livestream, last_livestream, stream_token, is_live, avatar, offline_background, description, links, tags, app_role
`

type UserUpdateParams struct {
	NameDoUpdate      bool
	Name              string
	PasswordDoUpdate  bool
	Password          string
	IsBannedDoUpdate  bool
	IsBanned          pgtype.Bool
	IsPartnerDoUpdate bool
	IsPartner         pgtype.Bool
	AvatarDoUpdate    bool
	Avatar            pgtype.Text
	ID                int32
}

func (q *Queries) UserUpdate(ctx context.Context, arg UserUpdateParams) error {
	_, err := q.db.Exec(ctx, userUpdate,
		arg.NameDoUpdate,
		arg.Name,
		arg.PasswordDoUpdate,
		arg.Password,
		arg.IsBannedDoUpdate,
		arg.IsBanned,
		arg.IsPartnerDoUpdate,
		arg.IsPartner,
		arg.AvatarDoUpdate,
		arg.Avatar,
		arg.ID,
	)
	return err
}
