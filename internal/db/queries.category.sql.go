// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.category.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const categoryAddTags = `-- name: CategoryAddTags :many
WITH inserted AS (
INSERT INTO
    tc_category_tag (id_category, id_tag)
    SELECT
        $1::int,
        UNNEST($2::int[])
    ON CONFLICT
        (id_category, id_tag)
    DO NOTHING
    RETURNING id_category, id_tag
)
SELECT
    inserted.id_tag AS tag_id,
    name AS tag_name
FROM
    inserted
INNER JOIN
    tc_tag
ON
    inserted.id_tag = tc_tag.id
WHERE
    id_tag = inserted.id_tag
`

type CategoryAddTagsParams struct {
	Column1 int32
	Column2 []int32
}

type CategoryAddTagsRow struct {
	TagID   int32
	TagName string
}

func (q *Queries) CategoryAddTags(ctx context.Context, arg CategoryAddTagsParams) ([]CategoryAddTagsRow, error) {
	rows, err := q.db.Query(ctx, categoryAddTags, arg.Column1, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CategoryAddTagsRow
	for rows.Next() {
		var i CategoryAddTagsRow
		if err := rows.Scan(&i.TagID, &i.TagName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const categoryDelete = `-- name: CategoryDelete :exec
DELETE FROM
    tc_category
WHERE
    id = $1
`

func (q *Queries) CategoryDelete(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, categoryDelete, id)
	return err
}

const categoryDeleteTags = `-- name: CategoryDeleteTags :exec
DELETE FROM
    tc_category_tag
WHERE
    id_category = $1
`

func (q *Queries) CategoryDeleteTags(ctx context.Context, idCategory int32) error {
	_, err := q.db.Exec(ctx, categoryDeleteTags, idCategory)
	return err
}

const categoryInsert = `-- name: CategoryInsert :one
INSERT INTO
    tc_category(name, link, image)
VALUES
    ($1, $2, $3)
RETURNING id, name, link, created_at, is_safe, viewers, image
`

type CategoryInsertParams struct {
	Name  string
	Link  string
	Image string
}

func (q *Queries) CategoryInsert(ctx context.Context, arg CategoryInsertParams) (TcCategory, error) {
	row := q.db.QueryRow(ctx, categoryInsert, arg.Name, arg.Link, arg.Image)
	var i TcCategory
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Link,
		&i.CreatedAt,
		&i.IsSafe,
		&i.Viewers,
		&i.Image,
	)
	return i, err
}

const categorySelect = `-- name: CategorySelect :one
SELECT
    id, name, link, created_at, is_safe, viewers, image
FROM
    tc_category
WHERE
    id = $1
LIMIT 1
`

func (q *Queries) CategorySelect(ctx context.Context, id int32) (TcCategory, error) {
	row := q.db.QueryRow(ctx, categorySelect, id)
	var i TcCategory
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Link,
		&i.CreatedAt,
		&i.IsSafe,
		&i.Viewers,
		&i.Image,
	)
	return i, err
}

const categorySelectMany = `-- name: CategorySelectMany :many
SELECT
    c.id AS category_id,
    c.name AS category_name,
    is_safe,
    viewers,
    image,
    t.id AS tag_id,
    t.name AS tag_name
FROM
    tc_category c
LEFT OUTER JOIN
    tc_category_tag ct ON ct.id_category = c.id
LEFT OUTER JOIN
    tc_tag t ON t.id = ct.id_tag
LIMIT $1
OFFSET $2
`

type CategorySelectManyParams struct {
	Limit  int64
	Offset int64
}

type CategorySelectManyRow struct {
	CategoryID   int32
	CategoryName string
	IsSafe       bool
	Viewers      int32
	Image        string
	TagID        pgtype.Int4
	TagName      pgtype.Text
}

func (q *Queries) CategorySelectMany(ctx context.Context, arg CategorySelectManyParams) ([]CategorySelectManyRow, error) {
	rows, err := q.db.Query(ctx, categorySelectMany, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CategorySelectManyRow
	for rows.Next() {
		var i CategorySelectManyRow
		if err := rows.Scan(
			&i.CategoryID,
			&i.CategoryName,
			&i.IsSafe,
			&i.Viewers,
			&i.Image,
			&i.TagID,
			&i.TagName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const categoryUpdate = `-- name: CategoryUpdate :exec
UPDATE tc_category
SET
    name = CASE WHEN $1::boolean THEN $2 ELSE name END,
    link = CASE WHEN $3::boolean THEN $4 ELSE link END,
    is_safe = CASE WHEN $5::boolean THEN $6 ELSE is_safe END,
    image = CASE WHEN $7::boolean THEN $8 ELSE image END
WHERE
    id = $9
RETURNING id, name, link, created_at, is_safe, viewers, image
`

type CategoryUpdateParams struct {
	NameDoUpdate   bool
	Name           string
	LinkDoUpdate   bool
	Link           string
	IsSafeDoUpdate bool
	IsSafe         bool
	ImageDoUpdate  bool
	Image          string
	ID             int32
}

func (q *Queries) CategoryUpdate(ctx context.Context, arg CategoryUpdateParams) error {
	_, err := q.db.Exec(ctx, categoryUpdate,
		arg.NameDoUpdate,
		arg.Name,
		arg.LinkDoUpdate,
		arg.Link,
		arg.IsSafeDoUpdate,
		arg.IsSafe,
		arg.ImageDoUpdate,
		arg.Image,
		arg.ID,
	)
	return err
}
